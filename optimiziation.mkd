name: inverse
layout: true
class: center, middle, inverse

---

# Profiling and code optimization

## Radovan Bast

Licensed under [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/).
Code examples: [OSI](http://opensource.org)-approved [MIT license](http://opensource.org/licenses/mit-license.html).

---

layout: false

## Priorities

- write me

---

## Profiling

<img src="img/profile.png" style="width: 200px;"/>

- Where does the program spend most time?
- Dynamic program analysis (runtime)
- Statistical sampling or event-based
- Profiling perturbs the calculation

---

## Profile first, optimize later

- write me

---

## Performance analysis

- Programming

- Compilation parameters
    - "Right" compiler
    - Compiler flags
    - Instruction set
    - Optimized libraries

- Runtime parameters
    - "Right" machine
    - Memory
    - I/O
    - Parallelization
    - Adapting parameters to system size

- With relatively easy steps analyze whether application runs efficiently

---

## Easy language first

- write me

---

## Easy algorithm first

- write me

---

## Scaling and bottlenecks

- pre-factor
- scaling
- YAGNI

---

## Moving target

- multi-processor
- multi-thread

---

## Disk and memory access

- caching
- memoization
- recompute
- MPI and scaling (disk access serializing)

---

## Do not reinvent the wheel

- libraries
- libraries are dependencies

---

## Elemental functions

- write me

---

## Pure functions

- write me

---

## Intrinsics

- write me

---

## Timers

- write me

---

## Multiple loops

- allocating/deallocating inside of multiple loops

---

## Amdahl

<img src="img/amdahl.png" style="width: 700px;"/>

---

## Matlab

- write me

---

## Performance vs. obfuscation

- complexity
- intrinsics

---

## Human time vs. CPU time

- write me

---

## Prefactor vs. scaling

- write me

---

## Moore's law

- write me

---

## Refactoring

- natural process
- needs tests

---

## Conclusions

### Performance is typically not portable

### Typical problems

- Parallel region too small
- Serialization of parallel tasks
- I/O heavy code
- Communication overhead
- Work load imbalance
- Resource imbalance
- Memory-bound code
- Sub-optimal use of libraries
- System size too small
- Wrong code

---

## Conclusions

### Advice

- Profile first, optimize later
- Trust but verify
