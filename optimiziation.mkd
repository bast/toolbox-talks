name: inverse
layout: true
class: center, middle, inverse

---

# Profiling and code optimization

## Radovan Bast

Licensed under [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/).
Code examples: [OSI](http://opensource.org)-approved [MIT license](http://opensource.org/licenses/mit-license.html).

---

layout: false

## Priorities

- write me

---

## Profiling

<img src="img/profile.png" style="width: 200px;"/>

- Where does the program spend most time?
- Dynamic program analysis (runtime)
- Statistical sampling or event-based
- Profiling perturbs the calculation

---

## Profile first, optimize later

- write me

---

## Performance analysis

- Programming

- Compilation parameters
    - "Right" compiler
    - Compiler flags
    - Instruction set
    - Optimized libraries

- Runtime parameters
    - "Right" machine
    - Memory
    - I/O
    - Parallelization
    - Adapting parameters to system size

- With relatively easy steps analyze whether application runs efficiently

---

## Easy language first

- write me

---

## Easy algorithm first

- write me

---

## Scaling and bottlenecks

- pre-factor
- scaling
- YAGNI

---

## Moving target

- multi-processor
- multi-thread

---

## Maybe port

- Restructure mathematical formulation
- Innovate at algorithm level
- Then maybe port

---

## Disk and memory access

- Caching
- Cache hierarchy
- Distance to data
- Gorilla
- Memoization
- Recompute
- MPI and scaling (disk access serializing)

---

## Do not reinvent the wheel

- libraries
- libraries are dependencies

---

## Elemental functions

- write me

---

## Pure functions

- write me

---

## Intrinsics

- write me

---

## Timers

- write me

---

## Frequency race

- "The party isn't exactly over, but the police has arrived, and the music has been turned way down" (P. Kogge)

---

## Multiple loops

- allocating/deallocating inside of multiple loops

---

## Amdahl

<img src="img/amdahl.png" style="width: 400px;"/>

- Serial and parallel part scale differently w.r.t. system size

---

## Matlab

- write me

---

## Performance vs. obfuscation

- complexity
- intrinsics

---

## Human time vs. CPU time

- write me

---

## Prefactor vs. scaling

- write me

---

## Moore's law

- write me

---

## Refactoring

- natural process
- needs tests

---

## Profilers

## Event-based (tracing)

- Collect data (traces) for pre-defined events (entering or leaving functions, object allocation, communication, disk I/O)
- Modify the code
- Often large overhead
- Selective

## Statistical (sampling)

- Collect data at regular intervals
- Typically small overhead
- Not all code is seen
- May differ between execution
- Show bottlenecks in production code
- Can be used for monitoring over long execution runs
- Reports on external library functions

---

## Profilers

- Free
    - Gprof
    - Callgrind (Valgrind)
    - Python: cProfile, profile
    - OProfile

- HPC, free
    - HPCToolkit
    - DynInst
    - Extrae/Paraver
    - Scalasca
    - TAU

- Commercial
    - Vampir
    - Allinea Performance Reports
    - Allinea MAP
    - CrayPat
    - VTune Amplifier (Intel)

---

## Conclusions

### Performance is typically not portable

### Typical problems

- Parallel region too small
- Serialization of parallel tasks
- I/O heavy code
- Communication overhead
- Work load imbalance
- Resource imbalance
- Memory-bound code
- Sub-optimal use of libraries
- System size too small
- Wrong code

---

## Conclusions

### Advice

- Profile first, optimize later
- Trust but verify
